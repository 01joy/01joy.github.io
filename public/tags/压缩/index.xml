<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>压缩 on bitJoy</title>
    <link>http://localhost:1313/tags/%E5%8E%8B%E7%BC%A9/</link>
    <description>Recent content in 压缩 on bitJoy</description>
    <generator>Hugo -- 0.148.2</generator>
    <language>en</language>
    <lastBuildDate>Thu, 18 Aug 2016 09:54:55 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E5%8E%8B%E7%BC%A9/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Huffman编码压缩算法及其实现</title>
      <link>http://localhost:1313/posts/2016-08-18-the-implementation-of-huffman-code/</link>
      <pubDate>Thu, 18 Aug 2016 09:54:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/2016-08-18-the-implementation-of-huffman-code/</guid>
      <description>&lt;p&gt;哈弗曼编码是一个很经典的压缩算法，压缩率能达到50%，甚至更低。它的基本原理包括四个步骤：&lt;/p&gt;
&lt;p&gt;统计文件中每个字符出现的频率。
构建一个哈弗曼树。建树的过程是不断的合并频率最小的两个节点，父亲节点的频率为两个孩子节点的频率之和。如此循环直到合并成一个根节点。叶子节点为不同的字符及其频率。
生成哈弗曼编码。从树根开始对树进行编码，比如进入左孩子的边标记为0，进入右孩子的边标记为1，这里的0和1都是二进制位。这样之后，每个叶子节点都有一个唯一的二进制编码，这就是哈弗曼编码。频率越低的字符哈弗曼编码越长，频率越高的字符哈弗曼编码越短，这样就能起到压缩的效果。
第二遍扫描文件，把字符转换为对应的哈弗曼编码，保存成压缩文件。
解压缩的过程就是解析二进制位，然后查找哈弗曼树，每找到一个叶子节点，就解析出一个字符，直到解析完所有二进制位。下面详细解释我的C++实现。&lt;/p&gt;
&lt;p&gt;首先定义一个哈弗曼编码类，对外只提供压缩Compress和解压缩Decompress两个接口。值得注意的是有一个Node结构体，用于构成哈弗曼树的节点。此外count_node的key是字符频率，value是所在节点，且是multimap类型的，所以count_node会自动按字符频率有小到大排序，在构建哈弗曼树时，每次只需要取count_node的前两个节点进行合并即可。&lt;/p&gt;
&lt;p&gt;[cpp]
class HuffmanCode {
public:
HuffmanCode();&lt;/p&gt;
&lt;p&gt;void Compress(string src, string dest);
void Decompress(string src, string dest);&lt;/p&gt;
&lt;p&gt;virtual ~HuffmanCode();&lt;/p&gt;
&lt;p&gt;private:
void CountLetter(string src);
void ConstructHuffmanTree();
void GenerateHuffmanCode();
void WriteHuffmanCode(ofstream &amp;amp;os);
void Compressing(string src, string dest);&lt;/p&gt;
&lt;p&gt;void InsertIntoHuffmanTree(char letter, string &amp;amp;code, int &amp;amp;k);
void ConstructHuffmanTreeFromFile(ifstream &amp;amp;is);
void Decompressing(ifstream &amp;amp;is, ofstream &amp;amp;os);&lt;/p&gt;
&lt;p&gt;map&amp;lt;char, int&amp;gt; letter_count;
typedef struct Node {
int id;
bool is_leaf;
char letter;
int parent, lchild, rchild;
Node() {
}
Node(int i, bool il, char lt, int p, int lc, int rc) :
id(i), is_leaf(il), letter(lt), parent(p), lchild(lc), rchild(
rc) {
}
};
multimap&amp;lt;int, Node&amp;gt; count_node;
vector&lt;!-- raw HTML omitted --&gt; huffman_tree;
map&amp;lt;char, vector&lt;!-- raw HTML omitted --&gt;&amp;gt; letter_hcode; // hufman code for each letter
};
[/cpp]&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
