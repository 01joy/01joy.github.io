<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>快速排序 on bitJoy</title>
    <link>http://localhost:1313/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
    <description>Recent content in 快速排序 on bitJoy</description>
    <generator>Hugo -- 0.148.2</generator>
    <language>en</language>
    <lastBuildDate>Thu, 18 Aug 2016 11:00:43 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>稳定版快速排序算法</title>
      <link>http://localhost:1313/posts/2016-08-18-the-stable-quick-sort/</link>
      <pubDate>Thu, 18 Aug 2016 11:00:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/2016-08-18-the-stable-quick-sort/</guid>
      <description>&lt;p&gt;我们知道常规的快速排序算法是一个不稳定的算法，也就是两个相等的数排序之后的顺序可能和在原序列中的顺序不同。这是因为当选定一个枢轴（pivot），要把其他数分到小于pivot和大于pivot的两边的时候，不同实现的分法不一样。&lt;/p&gt;
&lt;p&gt;下面我实现了一种稳定版快速排序算法，在Partition函数中保持了原序列中所有元素的相对顺序，只把pivot放到了它的正确位置。具体方法是三遍扫描原序列：1）第一遍先把小于pivot的元素按先后顺序放到tmp里，然后把pivot放到它的正确位置tmp[k]；2）第二遍把大于pivot的元素按先后顺序追加在tmp里，这样除了pivot以前的其他元素，都保持了和原序列中一样的顺序；3）第三遍把tmp赋值回原数组A。&lt;/p&gt;
&lt;p&gt;当排序算法稳定之后，就可以借此统计逆序数了，文件Q5.txt中共包含100000个不同的整数，每行一个数。我们可以使用稳定版快速排序算法对其排序，并统计出其中的逆序数个数。&lt;/p&gt;
&lt;p&gt;具体的Python 3实现如下：&lt;/p&gt;
&lt;p&gt;[python]&lt;/p&gt;
&lt;h1 id=&#34;---coding-utf-8---&#34;&gt;-&lt;em&gt;- coding: utf-8 -&lt;/em&gt;-&lt;/h1&gt;
&lt;p&gt;&amp;quot;&amp;quot;&amp;quot;
Created on Tue Oct 6 00:21:37 2015
@author: bitjoy
&amp;quot;&amp;quot;&amp;quot;
import time&lt;/p&gt;
&lt;p&gt;inversions = 0&lt;/p&gt;
&lt;p&gt;def Partition(A, p, r):
global inversions
tmp = [0] * (r-p+1)
pivot = A[p]
k = 0
for i in range(p+1, r+1): # first
if A[i] &amp;lt; pivot:
tmp[k] = A[i]
inversions = inversions + i – k – p
k = k + 1
tmp[k] = pivot
ans = k + p
k = k + 1
for i in range(p+1, r+1): # second
if A[i] &amp;gt; pivot:
tmp[k] = A[i]
k = k + 1
k = 0
for i in range(p, r+1): # third
A[i] = tmp[k]
k = k + 1
return ans&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
