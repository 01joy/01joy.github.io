<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C&#43;&#43; on bitJoy</title>
    <link>http://localhost:1313/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on bitJoy</description>
    <generator>Hugo -- 0.148.2</generator>
    <language>en</language>
    <lastBuildDate>Sat, 24 Sep 2016 20:37:05 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;基本数据类型备忘</title>
      <link>http://localhost:1313/posts/2016-09-24-memo-about-cpp-built-in-types/</link>
      <pubDate>Sat, 24 Sep 2016 20:37:05 +0800</pubDate>
      <guid>http://localhost:1313/posts/2016-09-24-memo-about-cpp-built-in-types/</guid>
      <description>&lt;p&gt;今天阅读《C++ Primer, 5e》的第二章，介绍C++的基本内置类型，觉得有一些平时工作容易出错的知识点，现摘录如下：&lt;/p&gt;
&lt;p&gt;[cpp]
unsigned char c = -1; // 假设char占8比特，c的值为255
[/cpp]&lt;/p&gt;
&lt;p&gt;当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsigned char所得的结果是255。&lt;/p&gt;
&lt;p&gt;[cpp]
signed char c2 = 256; // 假设char占8比特，c2的值是未定义的
[/cpp]&lt;/p&gt;
&lt;p&gt;当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。&lt;/p&gt;
&lt;p&gt;[cpp]
unsigned u = 10;
int i = -42;
std::cout &amp;laquo; i + i &amp;laquo; std::endl; // 输出-84
std::cout &amp;laquo; u + i &amp;laquo; std::endl; // 如果int占32位，输出4294967264
[/cpp]&lt;/p&gt;
&lt;p&gt;在第一个输出表达式里，两个（负）整数相加并得到了期望的结果。在第二个输出表达式里，相加前首先把整数-42转换成无符号数。把负数转换成无符号数类似于直接给无符号数赋一个负数，结果等于这个负数加上无符号数的模。unsigned (int)的取值范围是0~&lt;/p&gt;
$$2^{32}-1$$&lt;p&gt;，所以总数有&lt;/p&gt;
$$2^{32}$$&lt;p&gt;个数，-42%&lt;/p&gt;
$$2^{32}$$&lt;p&gt;=-42+&lt;/p&gt;
$$2^{32}$$&lt;p&gt;，u+i=10+(-42+&lt;/p&gt;
$$2^{32}$$&lt;p&gt;)=4294967264。&lt;/p&gt;
&lt;p&gt;[cpp]
unsigned u1 = 42, u2 = 10;
std::cout &amp;laquo; u1 – u2 &amp;laquo; std::endl; // 正确：输出32
std::cout &amp;laquo; u2 – u1 &amp;laquo; std::endl; // 正确：不过，结果是取模后的值
[/cpp]&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
